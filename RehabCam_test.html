<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8"/>
  <title>Shoulder Rehab (Web) — Max Angle Logger</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    :root { --bg:#0b0c10; --card:#141518; --line:#23262c; --text:#eaeaea; --muted:#9aa0a6; --ok:#2fd37a; --bad:#ff4d4f; --warn:#f6c64e; }
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Segoe UI,Arial,sans-serif}
    header{padding:12px 16px;border-bottom:1px solid var(--line);background:#111;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    header .tag{border:1px solid var(--line);border-radius:999px;padding:4px 10px;font-size:12px;color:var(--muted)}
    main{display:grid;grid-template-columns:1.2fr 1fr;gap:12px;padding:12px}
    .panel{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:12px}
    .stack{position:relative}
    video,canvas{width:100%;border-radius:12px;display:block;background:#0f1014;min-height:300px}
    #overlay{position:absolute;left:0;top:0}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .col{display:flex;flex-direction:column;gap:8px}
    button,select{background:#1c1f26;border:1px solid var(--line);color:var(--text);border-radius:8px;padding:8px 10px}
    input[type=range], input[type=number]{background:#1c1f26;color:var(--text);border:1px solid var(--line);border-radius:8px;padding:6px 8px}
    label{color:var(--muted)}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .stat{font-variant-numeric:tabular-nums}
    small{color:var(--muted)}
    @media (max-width:1100px){ main{grid-template-columns:1fr}}
  </style>
</head>
<body>
<header>
  <strong>Shoulder Rehab (Web)</strong>
  <span class="tag">Max Angle (hold ≥ 1.5s)</span>
  <span class="tag">Mode reset & replot</span>
  <span class="tag">Camera toggle</span>
</header>

<main>
  <div id="loader" style="margin:10px 12px;padding:10px;border:1px solid #23262c;border-radius:10px;background:#141518;color:#9aa0a6;display:none;">
    ⏳ 正在预加载模型与运行环境（可直接点击“开启摄像头”，加载完会更快）…
  </div>
  <section class="panel">
    <div class="stack">
      <video id="video" playsinline autoplay muted></video>
      <canvas id="overlay"></canvas>
    </div>

    <div class="row" style="margin-top:10px">
      <div class="row">
        <label>侧别</label>
        <select id="sideMode">
          <option value="LEFT">LEFT</option>
          <option value="RIGHT">RIGHT</option>
          <option value="BOTH" selected>BOTH</option>
        </select>
      </div>
      <div class="row">
        <label>动作</label>
        <select id="movement">
          <option value="flexion">1 前屈</option>
          <option value="extension">2 后伸</option>
          <option value="abduction">3 外展</option>
          <option value="int_ext_rot">4 内/外旋(双向)</option>
        </select>
      </div>
      <div class="row">
        <label>EMA α</label>
        <input id="alpha" type="range" min="0.05" max="0.6" step="0.01" value="0.2"/>
        <span id="alphaVal">0.20</span>
      </div>
      <div class="row">
        <label>最小角度阈值（记录门槛）</label>
        <input id="minAngle" type="number" value="30" min="0" max="180" step="1" style="width:90px"/>
        <small>需连续 ≥1.5s 超过该角度且刷新最大值，才会被记录为本轮最大角</small>
      </div>
      <div class="row">
        <button id="btnCsv">开始记录 CSV</button>
        <button id="btnSwap">左右交换</button>
        <button id="btnMirror">镜像预览</button>
        <button id="btnReset">重置当前模式</button>
        <button id="btnVoice">开启语音</button>
      </div>
    </div>

    <div class="grid2" style="margin-top:10px">
      <div class="col">
        <div>Left: <span id="angL" class="stat">--.-°</span> | Max <span id="maxL" class="stat">--.-°</span></div>
        <div>Right: <span id="angR" class="stat">--.-°</span> | Max <span id="maxR" class="stat">--.-°</span></div>
        <small>Flex/Abd ≥150°, Ext ≥40°, IR/ER ≥60° 可自行调整</small>
      </div>
      <div class="col">
        <div>FPS: <span id="fps">0</span></div>
        <div>模型: PoseLandmarker (full)</div>
      </div>
    </div>
  </section>

  <section class="panel">
    <div class="row" style="margin-bottom: 10px;">
      <button id="btnCam">关闭摄像头</button>
    </div>
    <canvas id="chart" height="250"></canvas>
  </section>
</main>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
<script type="module">
import { FilesetResolver, PoseLandmarker, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.11";

const MODEL_URL="https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task";

const video=document.getElementById("video");
const canvas=document.getElementById("overlay");
const ctx=canvas.getContext("2d");
const sideSel=document.getElementById("sideMode");
const moveSel=document.getElementById("movement");
const alphaSlider=document.getElementById("alpha");
const alphaVal=document.getElementById("alphaVal");
const minAngleInput=document.getElementById("minAngle");
const btnCsv=document.getElementById("btnCsv");
const btnSwap=document.getElementById("btnSwap");
const btnMirror=document.getElementById("btnMirror");
const btnReset=document.getElementById("btnReset");
const btnVoice=document.getElementById("btnVoice");
const btnCam=document.getElementById("btnCam");
const angL_el=document.getElementById("angL");
const angR_el=document.getElementById("angR");
const maxL_el=document.getElementById("maxL");
const maxR_el=document.getElementById("maxR");
const fps_el=document.getElementById("fps");
// 默认 BOTH 模式
sideSel.value="BOTH";

let mirror=false, swapSides=false, EMA_ALPHA=parseFloat(alphaSlider.value);
alphaSlider.addEventListener("input",()=>{ EMA_ALPHA=parseFloat(alphaSlider.value); alphaVal.textContent=EMA_ALPHA.toFixed(2); });

const HOLD_SECONDS=1.5; // 必须持续 1.5s 才认定最大角
const MOVEMENTS={ flexion:{desc:"Flexion",threshold_ok:150}, extension:{desc:"Extension",threshold_ok:40}, abduction:{desc:"Abduction",threshold_ok:150}, int_rot:{desc:"Int Rot",threshold_ok:60}, ext_rot:{desc:"Ext Rot",threshold_ok:60} };
const IDX={ NOSE:0, LSH:11, RSH:12, LEL:13, REL:14, LWR:15, RWR:16, LHIP:23, RHIP:24, LANK:27, RANK:28, LHEEL:29, RHEEL:30, LFOOT:31, RFOOT:32 };
const LEFT ={hip:IDX.LHIP, shoulder:IDX.LSH, elbow:IDX.LEL, wrist:IDX.LWR};
const RIGHT={hip:IDX.RHIP, shoulder:IDX.RSH, elbow:IDX.REL, wrist:IDX.RWR};
function getMapFor(which, swapped){ if(which==="LEFT") return swapped?RIGHT:LEFT; else return swapped?LEFT:RIGHT; }
function sub(a,b){ return [a[0]-b[0],a[1]-b[1],a[2]-b[2]]; }
function dot(a,b){ return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
function cross(a,b){ return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
function norm(a){ const n=Math.hypot(a[0],a[1],a[2]); return n>0?n:0; }
function normalize(a){ const n=norm(a); return n?[a[0]/n,a[1]/n,a[2]/n]:[0,0,0]; }
function angleBetween(v1,v2){ const n1=norm(v1),n2=norm(v2); if(!n1||!n2) return NaN; let c=dot(v1,v2)/(n1*n2); c=Math.max(-1,Math.min(1,c)); return Math.acos(c)*180/Math.PI; }
function planarAngle2D(a2,b2){ return angleBetween([a2[0],a2[1],0],[b2[0],b2[1],0]); }

let maxData = {
  LEFT_EXT: { ang: 0, tStart: null },
  LEFT_INT: { ang: 0, tStart: null },
  RIGHT_EXT: { ang: 0, tStart: null },
  RIGHT_INT: { ang: 0, tStart: null }
};

function updateMax(key, val, tRel, minAngle){
  if (!Number.isFinite(val) || val < minAngle) { 
    maxData[key].tStart = null; 
    return; 
  }
  if (val > maxData[key].ang){
    if (maxData[key].tStart === null) maxData[key].tStart = tRel;
    if (tRel - maxData[key].tStart >= HOLD_SECONDS){
      maxData[key].ang = val;
      maxData[key].tStart = null;
    }
  }
}

// 对齐人体坐标
function alignToBodyFrame(world){
  const p=world.map(w=>[w.x,w.y,w.z]);
  const pelvis=[(p[IDX.LHIP][0]+p[IDX.RHIP][0])/2,(p[IDX.LHIP][1]+p[IDX.RHIP][1])/2,(p[IDX.LHIP][2]+p[IDX.RHIP][2])/2];
  const shoulderC=[(p[IDX.LSH][0]+p[IDX.RSH][0])/2,(p[IDX.LSH][1]+p[IDX.RSH][1])/2,(p[IDX.LSH][2]+p[IDX.RSH][2])/2];
  let up=normalize(sub(shoulderC,pelvis));
  let right=normalize(sub(p[IDX.RSH],p[IDX.LSH]));
  let fwd=normalize(cross(right,up));
  right=normalize(cross(up,fwd));
  const R=[right,up,fwd]; // 列向量
  const local=p.map(q=>sub(q,pelvis));
  let body=local.map(q=>[
    q[0]*R[0][0]+q[1]*R[0][1]+q[2]*R[0][2],
    q[0]*R[1][0]+q[1]*R[1][1]+q[2]*R[1][2],
    q[0]*R[2][0]+q[1]*R[2][1]+q[2]*R[2][2],
  ]);
  if(body[IDX.NOSE][2]<0){ body=body.map(v=>[-v[0],v[1],-v[2]]); }
  const sw=norm(sub(body[IDX.LSH],body[IDX.RSH])); if(sw>1e-6) body=body.map(v=>[v[0]/sw,v[1]/sw,v[2]/sw]);
  return body;
}
// EMA
let emaPts=null;
function emaUpdate(bf){
  if(!emaPts||emaPts.length!==bf.length) emaPts=bf.map(v=>v.slice());
  else emaPts=emaPts.map((v,i)=>[ EMA_ALPHA*bf[i][0]+(1-EMA_ALPHA)*v[0], EMA_ALPHA*bf[i][1]+(1-EMA_ALPHA)*v[1], EMA_ALPHA*bf[i][2]+(1-EMA_ALPHA)*v[2] ]);
  return emaPts;
}
// 123角度
function computeAngle(bf, sideMap, sideName, move){
  const hip=bf[sideMap.hip], sh=bf[sideMap.shoulder], el=bf[sideMap.elbow], wr=bf[sideMap.wrist];
  const v_body=sub(hip,sh), v_uarm=sub(el,sh), v_farm=sub(wr,el);
  const proj=(v,plane)=> plane==="sagittal"? [v[1],v[2]] : plane==="coronal"? [v[0],v[1]] : [v[0],v[2]];
  let ang=NaN;
  if(move==="flexion"){ ang=planarAngle2D(proj(v_uarm,"sagittal"), proj(v_body,"sagittal"));
  }else if(move==="extension"){ const a=planarAngle2D(proj(v_uarm,"sagittal"), proj(v_body,"sagittal")); const backward=(v_uarm[2]<0); ang=backward? a :0;
  }else if(move==="abduction"){ ang=planarAngle2D(proj(v_uarm,"coronal"), proj(v_body,"coronal"));
  }else{ // int/ext rot
    const v_farm=sub(wr,el);
    const oppositeShoulder=sideName === "LEFT" ? bf[IDX.RSH] : bf[IDX.LSH];
    const v_shoulders=sub(oppositeShoulder,sh);
    
    // 计算夹角a（XY平面投影）
    const v_farm_xy = [v_farm[0], v_farm[1]];
    const v_shoulders_xy = [v_shoulders[0], v_shoulders[1]];
    const angleA = planarAngle2D(v_farm_xy, v_shoulders_xy);
    
    // 计算夹角b（与横截面的角度）
    const v_farm_projection=[v_farm[0],0,v_farm[2]];
    const angleB=angleBetween(v_farm,v_farm_projection);
    
    let finalAngle=0;
    if(move==="int_rot"){
      finalAngle=90 - angleA;
      if(angleA >90 || Math.abs(angleB)>30) finalAngle=0;
    }
    if(move==="ext_rot"){
      finalAngle=angleA -90;
      if(angleA <90 || Math.abs(angleB)>30) finalAngle=0;
    }
    ang=Math.max(0,Math.min(180,finalAngle));
  }
  const ok = Number.isFinite(ang) && ang >= MOVEMENTS[move].threshold_ok;
  return {angle:ang, ok};
}

//动作4角度
function computeDualRot(bf, sideName){
  const el = bf[sideName==="LEFT" ? IDX.LEL : IDX.REL];
  const wr = bf[sideName==="LEFT" ? IDX.LWR : IDX.RWR];

  // 前臂在 XY 平面的投影
  const v = [wr[0] - el[0], wr[1] - el[1]];
  // 中立参考方向（左=-X，右=+X）
  const ref = (sideName==="LEFT") ? [-1, 0] : [1, 0];
  // 与 ref 垂直的方向
  const perp = [ref[1], -ref[0]];

  // 1) 夹角大小（0~180°）
  const a = planarAngle2D(v, ref);
  // 2) 映射到 ±90：中立 90° → 0°
  let diff = 90 - a;

  // 3) 判断方向（点积符号）
  let s = v[0]*perp[0] + v[1]*perp[1];
  if (sideName === "LEFT") s = -s;  // 左手反转方向

  if (s < 0) diff = -diff; // 负=内旋，正=外旋

  const val = Math.max(-90, Math.min(90, diff));
  return {
    val,
    ext: val > 0 ? val : 0, // 外旋当前值
    int: val < 0 ? -val: 0  // 内旋当前值
  };
}



// Chart：双曲线
let chart=null;
function initChart(mode){
  if(chart){ chart.destroy(); }
  const ctxChart=document.getElementById("chart").getContext("2d");
  const isRot = (mode === "int_ext_rot");
  chart=new Chart(ctxChart,{
    type:"line",
    data:{labels:[], datasets:[
      {label:"Left", data:[], borderWidth:2, pointRadius:0, tension:.15},
      {label:"Right", data:[], borderWidth:2, pointRadius:0, tension:.15}
    ]},
    options:{responsive:true,animation:false,
      scales:{
        x:{title:{display:true,text:"Time (s)"},ticks:{color:"#9aa0a6"}},
        y:{title:{display:true,text:"Angle (deg)"},min:isRot?-90:0,max:isRot?90:190,ticks:{color:"#9aa0a6"}}
      },
      plugins:{legend:{labels:{color:"#eaeaea"}}}
    }
  });
}
initChart(moveSel.value);

const windowSec=10;

// ---- 最大角度记录（需持续 ≥ 1.5s），每次切换模式重置 ----
let t0=performance.now();
let maxL=0, maxR=0;        // “已确认”的最大角（本轮）
let candL=null, candR=null; // 候选最大角（超过minAngle且超过已确认max之后开始计时）
let tStartL=null, tStartR=null; // 候选开始时间（tRel）
function resetModeState(){
  // 清曲线+时间基准
  chart.data.labels.length=0;
  chart.data.datasets[0].data.length=0;
  chart.data.datasets[1].data.length=0;
  chart.update("none");
  t0=performance.now();
  // 重置最大角与候选
  maxL=maxR=0; candL=candR=null; tStartL=tStartR=null;
  maxL_el.textContent="--.-°"; maxR_el.textContent="--.-°";

  resetRotMax();
}

// —— mode4（内/外旋）分别最大值 ——
// 结构：每个 key 维护 { ang:已确认最大值, tStart:候选开始时间 }
let rotMax = {
  LEFT_EXT:{ang:0, tStart:null}, LEFT_INT:{ang:0, tStart:null},
  RIGHT_EXT:{ang:0, tStart:null}, RIGHT_INT:{ang:0, tStart:null}
};
function resetRotMax(){
  rotMax = {
    LEFT_EXT:{ang:0, tStart:null}, LEFT_INT:{ang:0, tStart:null},
    RIGHT_EXT:{ang:0, tStart:null}, RIGHT_INT:{ang:0, tStart:null}
  };
}

// val 是“当前方向的正值”（外旋或内旋），与 minAngle 比较；达到 HOLD_SECONDS 后确认
function updateRotMax(key, val, tRel, minAngle, side, movementLabel){
  if(!Number.isFinite(val) || val < minAngle){ 
    rotMax[key].tStart = null; 
    return; 
  }
  if(val > rotMax[key].ang + 0.1){
    if(rotMax[key].tStart===null) rotMax[key].tStart = tRel;
    if(tRel - rotMax[key].tStart >= HOLD_SECONDS){
      rotMax[key].ang = val;
      rotMax[key].tStart = null;
      // 写 CSV（沿用你原表头）
      if(csvOn){
        csvRows.push([new Date().toISOString(), sideSel.value, side, movementLabel, val.toFixed(2)]);
      }
    }
  }else{
    rotMax[key].tStart = null;
  }
}


// CSV：只需要记录“确认的最大角”事件
let csvOn=false;
let csvRows=[["timestamp_iso","mode","side","movement","max_angle_deg"]];
btnCsv.addEventListener("click",()=>{
  csvOn=!csvOn;
  btnCsv.textContent=csvOn? "停止记录 CSV":"开始记录 CSV";
  if(!csvOn && csvRows.length>1){
    const blob=new Blob([csvRows.map(r=>r.join(",")).join("\n")],{type:"text/csv"});
    const a=document.createElement("a");
    a.href=URL.createObjectURL(blob);
    a.download=`max_angles_${new Date().toISOString().replace(/[:.]/g,"-")}.csv`;
    a.click(); URL.revokeObjectURL(a.href);
    csvRows=[["timestamp_iso","mode","side","movement","max_angle_deg"]];
  }
});

// 左右交换/镜像/重置
btnSwap.addEventListener("click",()=>{ swapSides=!swapSides; btnSwap.textContent=swapSides? "左右已交换":"左右交换"; });
let mirrorOn=false; btnMirror.addEventListener("click",()=>{ mirrorOn=!mirrorOn; btnMirror.textContent=mirrorOn? "取消镜像":"镜像预览"; mirror=mirrorOn; });
btnReset.addEventListener("click", resetModeState);
// 侧别/动作变更时重置
sideSel.addEventListener("change", resetModeState);
moveSel.addEventListener("change", ()=>{
  resetModeState();
  initChart(moveSel.value);
});


// 摄像头开/关
let stream=null, landmarker=null, fileset=null;
let videoReady=false;
let camOn=true;
btnCam.addEventListener("click", async ()=>{
  if(camOn){
    camOn=false; btnCam.textContent="开启摄像头";
    videoReady=false;
    videoReady = false; if(stream){ stream.getTracks().forEach(t=>t.stop()); stream = null;}
    video.srcObject=null; ctx.clearRect(0,0,canvas.width,canvas.height);
  }else{
    btnCam.textContent = "关闭摄像头";
try {
  await startCamera();
  camOn = true;
  resetModeState();
  loop();
} catch (e) {
  camOn = false;
  btnCam.textContent = "开启摄像头";
  alert(`无法开启摄像头：${(e && e.name) ? e.name : e}\n\n请在浏览器地址栏的站点设置里允许摄像头，然后再次点击“开启摄像头”。`);
}
}
});

async function startCamera(){
  if (!stream) {
    stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:"user",width:{ideal:1280},height:{ideal:720}},audio:false});
  }
  video.srcObject=stream;

  await new Promise((resolve)=>{
    function ready(){
      if(video.videoWidth>0 && video.videoHeight>0){
        video.removeEventListener('loadedmetadata', ready);
        resolve();
      }
    }
    video.addEventListener('loadedmetadata', ready);
    if (video.readyState >= 2) ready();
  });
  await video.play();
  canvas.width=video.videoWidth||1280; 
  canvas.height=video.videoHeight||720;
  videoReady=true;

  if (!fileset) fileset = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.11/wasm");
  if (!landmarker) {
    landmarker = await PoseLandmarker.createFromOptions(fileset,{
      baseOptions:{modelAssetPath:MODEL_URL,delegate:"GPU"},
      runningMode:"VIDEO", numPoses:1, minPoseDetectionConfidence:0.5, minPosePresenceConfidence:0.5, minTrackingConfidence:0.5
    });
  }
}



// ===== 语音：合成 + 识别（不播报最大角，仅交互提示） =====
function speak(text){ try{ const u=new SpeechSynthesisUtterance(text); u.lang='zh-CN'; speechSynthesis.speak(u);}catch(e){} }

function setMovementByNumber(n){
  const map={1:'flexion',2:'extension',3:'abduction',4:'int_ext_rot'};
  if(map[n]){ moveSel.value = map[n]; moveSel.dispatchEvent(new Event('change')); speak(`已切换到动作${n}`); }
}

function ensureCsv(on){
  if(on && !csvOn){ btnCsv.click(); speak('开始记录'); }
  if(!on && csvOn){ btnCsv.click(); speak('停止记录'); }
}

let recognizer=null, recognizing=false;
function startRecognizer(){
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if(!SR){ alert('当前浏览器不支持语音识别。请使用最新版 Chrome/Edge。'); return; }
  recognizer = new SR();
  recognizer.lang = 'zh-CN';
  recognizer.continuous = true;
  recognizer.interimResults = false;

  recognizer.onresult = (ev)=>{
    const res = ev.results[ev.results.length-1][0].transcript.trim();
    const cmd = res.replace(/\s+/g,'');

    if(/^(开始记录|开始csv|开始CSV)$/.test(cmd)) { ensureCsv(true); return; }
    if(/^(停止记录|停止csv|停止CSV)$/.test(cmd)) { ensureCsv(false); return; }

    const numMap = {'一':1,'二':2,'两':2,'三':3,'四':4};
    let m = cmd.match(/动作([1234一二两三四])/);
    if(m){
      const token = m[1];
      const n = '1234'.includes(token) ? parseInt(token,10) : numMap[token];
      if(n) { setMovementByNumber(n); return; }
    }
    if(/^[1234]$/.test(cmd)){ setMovementByNumber(parseInt(cmd,10)); return; }
    if(/^[一二两三四]$/.test(cmd)){ setMovementByNumber(numMap[cmd]); return; }

    if(/^(开摄像头|开启摄像头)$/.test(cmd)){ if(!camOn) btnCam.click(); speak('已开启摄像头'); return; }
    if(/^(关摄像头|关闭摄像头)$/.test(cmd)){ if(camOn) btnCam.click(); speak('已关闭摄像头'); return; }
  };

  recognizer.onend = ()=>{ if(recognizing){ try{ recognizer.start(); }catch(e){} } };

  try{ recognizer.start(); recognizing = true; btnVoice.textContent='关闭语音'; speak('语音控制已开启'); }catch(e){}
}

function stopRecognizer(){
  if(recognizer){ recognizing=false; try{ recognizer.stop(); }catch(e){} }
  btnVoice.textContent='开启语音';
  speak('语音控制已关闭');
}

btnVoice.addEventListener('click', ()=>{ if(!recognizing) startRecognizer(); else stopRecognizer(); });


// ===== 预加载 Mediapipe 模型 & WASM =====
function setDisabled(el, on){ try{ el.disabled = !!on; el.style.opacity = on? .6 : 1; }catch(e){} }
async function prewarmModel(){
  const loader = document.getElementById('loader');
  try{
    loader.style.display = 'block';
    setStatus?.('正在加载模型与运行环境…');

    // 预初始化 FilesetResolver（会拉取 wasm）
    if(!fileset){
      fileset = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.11/wasm");
    }

    // 预拉取模型（利用浏览器缓存），不阻塞相机按钮
    try{ await fetch(MODEL_URL, {cache:'force-cache', mode:'cors'}); }catch(e){ /* 忽略预取错误 */ }

    // 可选：预创建 landmarker 加快首帧（失败则懒加载）
    if(!landmarker){
      try{
        landmarker = await PoseLandmarker.createFromOptions(fileset, {
          baseOptions:{ modelAssetPath: MODEL_URL, delegate: "GPU" },
          runningMode:"VIDEO", numPoses:1,
          minPoseDetectionConfidence:0.5, minPosePresenceConfidence:0.5, minTrackingConfidence:0.5
        });
      }catch(e){ console.warn('预创建 landmarker 失败，将在启动相机时再创建', e); }
    }

    setStatus?.('模型与运行环境已就绪');
  }catch(e){
    console.warn('预加载失败', e);
    setStatus?.('预加载失败（不影响使用）');
  }finally{
    loader.style.display = 'none';
  }
}
// 启动预热（不自动开摄像头）
prewarmModel();

// 主循环
const drawUtil = new DrawingUtils(ctx);
let lastTs = -1;
function loop(){
  if(!camOn){ requestAnimationFrame(loop); return; }

  const ts = performance.now(), tRel = (ts - t0) / 1000;

  // 调用 Mediapipe 检测
  let res=null;
  if(videoReady && video.videoWidth>0 && video.videoHeight>0){
    try{ res = landmarker?.detectForVideo(video, ts); }catch(e){ /* wait until ready */ }
  }

  // 先清空画布
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 镜像模式
  if(mirror){ ctx.save(); ctx.translate(canvas.width, 0); ctx.scale(-1, 1); }

  // 绘制视频背景
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  // 绘制骨架
  if(res?.landmarks?.[0]){
    drawUtil.drawLandmarks(res.landmarks[0], { radius: 2 });
    drawUtil.drawConnectors(res.landmarks[0], PoseLandmarker.POSE_CONNECTIONS);
  }

  // ===== 角度计算 / 最大值更新 / 曲线更新 =====
  if(res?.worldLandmarks?.[0]){
    let bf = alignToBodyFrame(res.worldLandmarks[0]);
    bf = emaUpdate(bf);

    const move = moveSel.value, mode = sideSel.value;
    const minAngle = parseFloat(minAngleInput.value) || 0;

    let angL = NaN, angR = NaN;
    let dispL = NaN, dispR = NaN;

    if (move === "int_ext_rot") {  
      // 模式4 双向内/外旋
      if (mode === "LEFT" || mode === "BOTH") {
        const L = computeDualRot(bf, "LEFT");
        updateRotMax("LEFT_EXT", L.ext, tRel, minAngle, "LEFT", "ext_rot");
        updateRotMax("LEFT_INT", L.int, tRel, minAngle, "LEFT", "int_rot");
        angL_el.textContent =
          `内:${L.int.toFixed(1)}° | max:${rotMax.LEFT_INT.ang.toFixed(1)}° / ` +
          `外:${L.ext.toFixed(1)}° | max:${rotMax.LEFT_EXT.ang.toFixed(1)}°`;
        dispL = L.val;
      } else {
        angL_el.textContent = "--.-°";
      }

      if (mode === "RIGHT" || mode === "BOTH") {
        const R = computeDualRot(bf, "RIGHT");
        updateRotMax("RIGHT_EXT", R.ext, tRel, minAngle, "RIGHT", "ext_rot");
        updateRotMax("RIGHT_INT", R.int, tRel, minAngle, "RIGHT", "int_rot");
        angR_el.textContent =
          `内:${R.int.toFixed(1)}° | max:${rotMax.RIGHT_INT.ang.toFixed(1)}° / ` +
          `外:${R.ext.toFixed(1)}° | max:${rotMax.RIGHT_EXT.ang.toFixed(1)}°`;
        dispR = R.val;
      } else {
        angR_el.textContent = "--.-°";
      }

    } else {  
      // 模式1/2/3 保留原有最大角逻辑
      if (mode === "LEFT" || mode === "BOTH") {
        const m = getMapFor("LEFT", swapSides);
        angL = computeAngle(bf, m, "LEFT", move).angle;
      }
      if (mode === "RIGHT" || mode === "BOTH") {
        const m = getMapFor("RIGHT", swapSides);
        angR = computeAngle(bf, m, "RIGHT", move).angle;
      }
      dispL = angL; 
      dispR = angR;
      angL_el.textContent = Number.isFinite(angL) ? `${angL.toFixed(1)}°` : "--.-°";
      angR_el.textContent = Number.isFinite(angR) ? `${angR.toFixed(1)}°` : "--.-°";

      // 最大角判定逻辑
      if (Number.isFinite(angL) && (mode==="LEFT"||mode==="BOTH")) {
        if (angL >= minAngle && angL > maxL + 0.1) {
          if (candL===null || angL > candL + 0.1) { candL = angL; tStartL = tRel; }
          if (tRel - tStartL >= HOLD_SECONDS) {
            maxL = candL; maxL_el.textContent = `${maxL.toFixed(1)}°`;
            if (csvOn) { csvRows.push([new Date().toISOString(), mode, "LEFT", move, maxL.toFixed(2)]); }
            candL = null; tStartL = null;
          }
        } else { candL = null; tStartL = null; }
      }
      if (Number.isFinite(angR) && (mode==="RIGHT"||mode==="BOTH")) {
        if (angR >= minAngle && angR > maxR + 0.1) {
          if (candR===null || angR > candR + 0.1) { candR = angR; tStartR = tRel; }
          if (tRel - tStartR >= HOLD_SECONDS) {
            maxR = candR; maxR_el.textContent = `${maxR.toFixed(1)}°`;
            if (csvOn) { csvRows.push([new Date().toISOString(), mode, "RIGHT", move, maxR.toFixed(2)]); }
            candR = null; tStartR = null;
          }
        } else { candR = null; tStartR = null; }
      }
    }

    // 曲线更新
    const labels = chart.data.labels, dsL = chart.data.datasets[0], dsR = chart.data.datasets[1];
    labels.push(tRel.toFixed(2));
    dsL.data.push(Number.isFinite(dispL) ? dispL : null);
    dsR.data.push(Number.isFinite(dispR) ? dispR : null);
    while (labels.length > 1 && tRel - parseFloat(labels[0]) > windowSec) {
      labels.shift(); dsL.data.shift(); dsR.data.shift();
    }
    chart.update("none");
  }

  if(mirror){ ctx.restore(); }

  // FPS
  if(lastTs > 0) fps_el.textContent = Math.round(1000 / (ts - lastTs));
  lastTs = ts;

  requestAnimationFrame(loop);
}


// 启动（不自动开机位；等待用户点击“开启摄像头”）
camOn = false;
btnCam.textContent = '开启摄像头';
// 注意：点击按钮时再 startCamera()/loop()
</script>
</body>
</html>