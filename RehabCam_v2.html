<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8"/>
  <title>Shoulder Rehab (Web) — Max Angle Logger</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    :root { --bg:#0b0c10; --card:#141518; --line:#23262c; --text:#eaeaea; --muted:#9aa0a6; --ok:#2fd37a; --bad:#ff4d4f; --warn:#f6c64e; }
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,Segoe UI,Arial,sans-serif}
    header{padding:12px 16px;border-bottom:1px solid var(--line);background:#111;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    header .tag{border:1px solid var(--line);border-radius:999px;padding:4px 10px;font-size:12px;color:var(--muted)}
    main{display:grid;grid-template-columns:1.2fr 1fr;gap:12px;padding:12px}
    .panel{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:12px}
    .stack{position:relative}
    video,canvas{width:100%;border-radius:12px;display:block;background:#0f1014;min-height:300px}
    #overlay{position:absolute;left:0;top:0}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .col{display:flex;flex-direction:column;gap:8px}
    button,select{background:#1c1f26;border:1px solid var(--line);color:var(--text);border-radius:8px;padding:8px 10px}
    input[type=range], input[type=number]{background:#1c1f26;color:var(--text);border:1px solid var(--line);border-radius:8px;padding:6px 8px}
    label{color:var(--muted)}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .stat{font-variant-numeric:tabular-nums}
    small{color:var(--muted)}
    @media (max-width:1100px){ main{grid-template-columns:1fr}}

    /* 双色进度条 */
    .progress{height:10px;background:#1c1f26;border:1px solid var(--line);border-radius:999px;overflow:hidden}
    .progress .bar{height:100%;width:0%}
    .progress.ok{outline:1px solid var(--ok)}
  </style>
</head>
<body>
<header>
  <strong>Shoulder Rehab (Web)</strong>
  <span class="tag">Max Angle (hold ≥ 1s)</span>
  <span class="tag">Stream CSV per event</span>
  <span class="tag">Camera toggle (默认关闭)</span>
</header>

<main>
  <div id="loader" style="margin:10px 12px;padding:10px;border:1px solid #23262c;border-radius:10px;background:#141518;color:#9aa0a6;display:none;">
    ⏳ 正在预加载模型与运行环境（可直接点击“开启摄像头”，加载完会更快）…
  </div>

  <section class="panel">
    <div class="stack">
      <video id="video" playsinline autoplay muted></video>
      <canvas id="overlay"></canvas>
    </div>

    <div class="row" style="margin-top:10px">
      <div class="row">
        <label>侧别</label>
        <select id="sideMode">
          <option value="LEFT">LEFT</option>
          <option value="RIGHT">RIGHT</option>
          <option value="BOTH" selected>BOTH</option>
        </select>
      </div>
      <div class="row">
        <label>动作</label>
        <select id="movement">
          <option value="flexion">1 前屈</option>
          <option value="extension">2 后伸</option>
          <option value="abduction">3 外展</option>
          <option value="int_ext_rot">4 内/外旋(双向)</option>
        </select>
      </div>
      <div class="row">
        <label>EMA α</label>
        <input id="alpha" type="range" min="0.05" max="0.6" step="0.01" value="0.2"/>
        <span id="alphaVal">0.20</span>
      </div>
      <div class="row">
        <label>最小角度阈值（记录门槛）</label>
        <input id="minAngle" type="number" value="30" min="0" max="180" step="1" style="width:90px"/>
        <small>需连续 ≥1s 超过该角度且刷新最大值，才会被记录为本轮最大角</small>
      </div>

      <!-- 通用目标角度（动作1/2/3使用） -->
      <div class="row">
        <label>目标角度</label>
        <input id="targetAngle" type="number" value="150" min="0" max="190" step="1" style="width:90px"/>
      </div>

      <!-- 动作4：内/外旋双标准 -->
      <div class="row" id="rotTargets" style="gap:12px;">
        <label>内旋目标</label>
        <input id="targetInt" type="number" value="60" min="0" max="90" step="1" style="width:90px"/>
        <label>外旋目标</label>
        <input id="targetExt" type="number" value="60" min="0" max="90" step="1" style="width:90px"/>
        <small>仅动作4使用</small>
      </div>

      <!-- 双色提示进度条（按当前方向显示“内/外”标签） -->
      <div class="col" style="gap:6px;margin-top:6px;width:100%">
        <div class="row" style="width:100%">
          <label style="width:72px">Left<span id="dirLTag" style="margin-left:6px;color:#9aa0a6"></span></label>
          <div class="progress" id="progL" style="flex:1"><div class="bar" id="barL"></div></div>
          <span id="gapL" class="stat" style="width:110px;text-align:right">差 --°</span>
        </div>
        <div class="row" style="width:100%">
          <label style="width:72px">Right<span id="dirRTag" style="margin-left:6px;color:#9aa0a6"></span></label>
          <div class="progress" id="progR" style="flex:1"><div class="bar" id="barR"></div></div>
          <span id="gapR" class="stat" style="width:110px;text-align:right">差 --°</span>
        </div>
      </div>

      <div class="row" style="margin-top:6px">
        <button id="btnCsv">开始记录 CSV</button>
        <button id="btnSwap">左右交换</button>
        <button id="btnMirror">镜像预览</button>
        <button id="btnReset">重置当前模式</button>
        <button id="btnVoice">开启语音</button>
      </div>
    </div>

    <div class="grid2" style="margin-top:10px">
      <div class="col">
        <div>Left: <span id="angL" class="stat">--.-°</span> | Max <span id="maxL" class="stat">--.-°</span></div>
        <div>Right: <span id="angR" class="stat">--.-°</span> | Max <span id="maxR" class="stat">--.-°</span></div>
        <small>Flex/Abd ≥150°, Ext ≥40°, IR/ER ≥60° 可自行调整</small>
      </div>
      <div class="col">
        <div>FPS: <span id="fps">0</span></div>
        <div>模型: PoseLandmarker (full)</div>
      </div>
    </div>
  </section>

  <section class="panel">
    <div class="row" style="margin-bottom: 10px;">
      <button id="btnCam">开启摄像头</button>
    </div>
    <canvas id="chart" height="250"></canvas>
  </section>
</main>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
<script type="module">
import { FilesetResolver, PoseLandmarker, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.11";

const MODEL_URL="https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/latest/pose_landmarker_full.task";

const video=document.getElementById("video");
const canvas=document.getElementById("overlay");
const ctx=canvas.getContext("2d");

const sideSel=document.getElementById("sideMode");
const moveSel=document.getElementById("movement");
const alphaSlider=document.getElementById("alpha");
const alphaVal=document.getElementById("alphaVal");
const minAngleInput=document.getElementById("minAngle");
const btnCsv=document.getElementById("btnCsv");
const btnSwap=document.getElementById("btnSwap");
const btnMirror=document.getElementById("btnMirror");
const btnReset=document.getElementById("btnReset");
const btnVoice=document.getElementById("btnVoice");
const btnCam=document.getElementById("btnCam");

const angL_el=document.getElementById("angL");
const angR_el=document.getElementById("angR");
const maxL_el=document.getElementById("maxL");
const maxR_el=document.getElementById("maxR");
const fps_el=document.getElementById("fps");

const targetInput = document.getElementById("targetAngle");
const targetIntInput = document.getElementById("targetInt");
const targetExtInput = document.getElementById("targetExt");
const barL = document.getElementById("barL");
const barR = document.getElementById("barR");
const gapL = document.getElementById("gapL");
const gapR = document.getElementById("gapR");
const progL = document.getElementById("progL");
const progR = document.getElementById("progR");
const dirLTag=document.getElementById("dirLTag");
const dirRTag=document.getElementById("dirRTag");

// 默认 BOTH 模式
sideSel.value="BOTH";

let mirror=false, swapSides=false, EMA_ALPHA=parseFloat(alphaSlider.value);
alphaSlider.addEventListener("input",()=>{ EMA_ALPHA=parseFloat(alphaSlider.value); alphaVal.textContent=EMA_ALPHA.toFixed(2); });

const HOLD_SECONDS=1; // 必须持续1s 才认定最大角
const MOVEMENTS={ flexion:{desc:"Flexion",threshold_ok:150}, extension:{desc:"Extension",threshold_ok:40}, abduction:{desc:"Abduction",threshold_ok:150}, int_rot:{desc:"Int Rot",threshold_ok:60}, ext_rot:{desc:"Ext Rot",threshold_ok:60} };

// 标准化 CSV 的动作名
const MOVE_LABEL = {
  flexion:   "flexion",
  extension: "extension",
  abduction: "abduction",  
  int_rot:   "int_rot",
  ext_rot:   "ext_rot"
};

const IDX={ NOSE:0, LSH:11, RSH:12, LEL:13, REL:14, LWR:15, RWR:16, LHIP:23, RHIP:24, LANK:27, RANK:28, LHEEL:29, RHEEL:30, LFOOT:31, RFOOT:32 };
const LEFT ={hip:IDX.LHIP, shoulder:IDX.LSH, elbow:IDX.LEL, wrist:IDX.LWR};
const RIGHT={hip:IDX.RHIP, shoulder:IDX.RSH, elbow:IDX.REL, wrist:IDX.RWR};

function getMapFor(which, swapped){ if(which==="LEFT") return swapped?RIGHT:LEFT; else return swapped?LEFT:RIGHT; }
function sub(a,b){ return [a[0]-b[0],a[1]-b[1],a[2]-b[2]]; }
function dot(a,b){ return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
function cross(a,b){ return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
function norm(a){ const n=Math.hypot(a[0],a[1],a[2]); return n>0?n:0; }
function normalize(a){ const n=norm(a); return n?[a[0]/n,a[1]/n,a[2]/n]:[0,0,0]; }
function angleBetween(v1,v2){ const n1=norm(v1),n2=norm(v2); if(!n1||!n2) return NaN; let c=dot(v1,v2)/(n1*n2); c=Math.max(-1,Math.min(1,c)); return Math.acos(c)*180/Math.PI; }
function planarAngle2D(a2,b2){ return angleBetween([a2[0],a2[1],0],[b2[0],b2[1],0]); }

// 对齐人体坐标
function alignToBodyFrame(world){
  const p=world.map(w=>[w.x,w.y,w.z]);
  const pelvis=[(p[IDX.LHIP][0]+p[IDX.RHIP][0])/2,(p[IDX.LHIP][1]+p[IDX.RHIP][1])/2,(p[IDX.LHIP][2]+p[IDX.RHIP][2])/2];
  const shoulderC=[(p[IDX.LSH][0]+p[IDX.RSH][0])/2,(p[IDX.LSH][1]+p[IDX.RSH][1])/2,(p[IDX.LSH][2]+p[IDX.RSH][2])/2];
  let up=normalize(sub(shoulderC,pelvis));
  let right=normalize(sub(p[IDX.RSH],p[IDX.LSH]));
  let fwd=normalize(cross(right,up));
  right=normalize(cross(up,fwd));
  const R=[right,up,fwd]; // 列向量
  const local=p.map(q=>sub(q,pelvis));
  let body=local.map(q=>[
    q[0]*R[0][0]+q[1]*R[0][1]+q[2]*R[0][2],
    q[0]*R[1][0]+q[1]*R[1][1]+q[2]*R[1][2],
    q[0]*R[2][0]+q[1]*R[2][1]+q[2]*[R[2][2]],
  ]);
  if(body[IDX.NOSE][2]<0){ body=body.map(v=>[-v[0],v[1],-v[2]]); }
  const sw=norm(sub(body[IDX.LSH],body[IDX.RSH])); if(sw>1e-6) body=body.map(v=>[v[0]/sw,v[1]/sw,v[2]/sw]);
  return body;
}

// EMA
let emaPts=null;
function emaUpdate(bf){
  if(!emaPts||emaPts.length!==bf.length) emaPts=bf.map(v=>v.slice());
  else emaPts=emaPts.map((v,i)=>[ EMA_ALPHA*bf[i][0]+(1-EMA_ALPHA)*v[0], EMA_ALPHA*bf[i][1]+(1-EMA_ALPHA)*v[1], EMA_ALPHA*bf[i][2]+(1-EMA_ALPHA)*v[2] ]);
  return emaPts;
}

// 123角度
function computeAngle(bf, sideMap, sideName, move){
  const hip=bf[sideMap.hip], sh=bf[sideMap.shoulder], el=bf[sideMap.elbow], wr=bf[sideMap.wrist];
  const v_body=sub(hip,sh), v_uarm=sub(el,sh);
  const proj=(v,plane)=> plane==="sagittal"? [v[1],v[2]] : plane==="coronal"? [v[0],v[1]] : [v[0],v[2]];
  let ang=NaN;
  if(move==="flexion"){ ang=planarAngle2D(proj(v_uarm,"sagittal"), proj(v_body,"sagittal"));
  }else if(move==="extension"){ const a=planarAngle2D(proj(v_uarm,"sagittal"), proj(v_body,"sagittal")); const backward=(v_uarm[2]<0); ang=backward? a :0;
  }else if(move==="abduction"){ ang=planarAngle2D(proj(v_uarm,"coronal"), proj(v_body,"coronal"));
  }
  return {angle:ang, ok: Number.isFinite(ang) && ang >= MOVEMENTS[move].threshold_ok};
}

// 动作4角度：返回 [-90,90]（负=内旋，正=外旋），并分别给出当前内/外旋正值
function computeDualRot(bf, sideName){
  const el = bf[sideName==="LEFT" ? IDX.LEL : IDX.REL];
  const wr = bf[sideName==="LEFT" ? IDX.LWR : IDX.RWR];
  const v = [wr[0] - el[0], wr[1] - el[1]];                 // XY 投影
  const ref = (sideName==="LEFT") ? [-1, 0] : [1, 0];       // 中立
  const perp = [ref[1], -ref[0]];                           // 垂线
  const a = planarAngle2D(v, ref);                          // 0..180
  let diff = 90 - a;                                       // 中立90->0
  let s = v[0]*perp[0] + v[1]*perp[1];
  if (sideName === "LEFT") s = -s;                         // 左手反向
  if (s < 0) diff = -diff;                                  // 负=内旋，正=外旋
  const val = Math.max(-90, Math.min(90, diff));
  return { val, ext: val>0?val:0, int: val<0? -val:0 };
}

// —— mode4（内/外旋）分别最大值 —— 结构：{ ang:已确认最大值, tStart:候选开始时间 }
let rotMax = {
  LEFT_EXT:{ang:0, tStart:null}, LEFT_INT:{ang:0, tStart:null},
  RIGHT_EXT:{ang:0, tStart:null}, RIGHT_INT:{ang:0, tStart:null}
};
function resetRotMax(){
  rotMax = {
    LEFT_EXT:{ang:0, tStart:null}, LEFT_INT:{ang:0, tStart:null},
    RIGHT_EXT:{ang:0, tStart:null}, RIGHT_INT:{ang:0, tStart:null}
  };
}

// ---- 曲线 & 状态 ----
const windowSec=10;
let chart=null;
function initChart(mode){
  if(chart){ chart.destroy(); }
  const ctxChart=document.getElementById("chart").getContext("2d");
  const isRot = (mode === "int_ext_rot");
  chart=new Chart(ctxChart,{
    type:"line",
    data:{labels:[], datasets:[
      {label:"Left", data:[], borderWidth:2, pointRadius:0, tension:.15},
      {label:"Right", data:[], borderWidth:2, pointRadius:0, tension:.15}
    ]},
    options:{responsive:true,animation:false,
      scales:{
        x:{title:{display:true,text:"Time (s)"},ticks:{color:"#9aa0a6"}},
        y:{title:{display:true,text:"Angle (deg)"},min:isRot?-90:0,max:isRot?90:190,ticks:{color:"#9aa0a6"}}
      },
      plugins:{legend:{labels:{color:"#eaeaea"}}}
    }
  });
}
initChart(moveSel.value);

let t0=performance.now();
let maxL=0, maxR=0;        // 1/2/3 已确认最大角
let candL=null, candR=null;
let tStartL=null, tStartR=null;
function resetModeState(){
  chart.data.labels.length=0;
  chart.data.datasets[0].data.length=0;
  chart.data.datasets[1].data.length=0;
  chart.update("none");
  t0=performance.now();
  maxL=maxR=0; candL=candR=null; tStartL=tStartR=null;
  maxL_el.textContent="--.-°"; maxR_el.textContent="--.-°";
  resetRotMax();
}

// ===== 进度条：三档色（<60%红 / 60-100%黄 / ≥100%绿），动作4按方向切换目标与标签 =====
function colorForPct(p){ if(p>=1) return 'var(--ok)'; if(p>=0.6) return 'var(--warn)'; return 'var(--bad)'; }
function sideProgress(current, tgt){
  if(!Number.isFinite(current)) return {pct:0,text:"差 --°",ok:false};
  const ok = tgt>0 && current >= tgt;
  const pct = tgt>0? Math.max(0, Math.min(1, current/Math.max(1,tgt))) : 0;
  const text = ok ? "合格" : (tgt > 0 ? `差 ${(tgt - current).toFixed(1)}°` : "差 --°");
  return {pct,text,ok};
}
function paintBar(barEl, progWrap, p){
  barEl.style.width = `${(p.pct * 100).toFixed(1)}%`;
  barEl.style.background = colorForPct(p.pct);
  progWrap.classList.toggle("ok", p.ok);
}

// ===== CSV（流式写入；停止时一次性下载，含 BOM 与合格列）=====
function qualify(val, tgt){ if(!Number.isFinite(val)||!Number.isFinite(tgt)||tgt<=0) return "不合格"; return val>=tgt?"合格":"不合格"; }
let csvOn=false;
let csvRows=[["timestamp_iso","mode","side","movement","max_angle_deg","qualified"]];
btnCsv.addEventListener("click",()=>{
  csvOn=!csvOn;
  btnCsv.textContent=csvOn? "停止记录 CSV":"开始记录 CSV";
  if(!csvOn && csvRows.length>1){
    const bom=new Uint8Array([0xEF,0xBB,0xBF]); // 防止中文乱码
    const body=csvRows.map(r=>r.join(",")).join("\r\n");
    const blob=new Blob([bom,body],{type:"text/csv;charset=utf-8"});
    const a=document.createElement("a");
    a.href=URL.createObjectURL(blob);
    a.download=`max_angles_${new Date().toISOString().replace(/[:.]/g,"-")}.csv`;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(a.href);
    // 清空表
    csvRows=[["timestamp_iso","mode","side","movement","max_angle_deg","qualified"]];
  }
});

// 左右交换/镜像/重置（不会触发导出）
btnSwap.addEventListener("click",()=>{ swapSides=!swapSides; btnSwap.textContent=swapSides? "左右已交换":"左右交换"; });
let mirrorOn=false; btnMirror.addEventListener("click",()=>{ mirrorOn=!mirrorOn; btnMirror.textContent=mirrorOn? "取消镜像":"镜像预览"; mirror=mirrorOn; });
btnReset.addEventListener("click", resetModeState);
sideSel.addEventListener("change", resetModeState);
moveSel.addEventListener("change", ()=>{ resetModeState(); initChart(moveSel.value); });

// 摄像头开/关（默认关闭）
let stream=null, landmarker=null, fileset=null;
let videoReady=false;
let camOn=false;
btnCam.addEventListener("click", async ()=>{
  if(camOn){
    camOn=false; btnCam.textContent="开启摄像头";
    videoReady=false;
    if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
    video.srcObject=null; ctx.clearRect(0,0,canvas.width,canvas.height);
  } else {
    btnCam.textContent = "关闭摄像头";
    try {
      await startCamera();
      camOn = true;
      resetModeState();
      loop();
    } catch (e) {
      camOn = false;
      btnCam.textContent = "开启摄像头";
      alert(`无法开启摄像头：${(e && e.name) ? e.name : e}\n\n请在浏览器地址栏的站点设置里允许摄像头，然后再次点击“开启摄像头”。`);
    }
  }
});

async function startCamera(){
  if (!stream) {
    stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:"user",width:{ideal:1280},height:{ideal:720}},audio:false});
  }
  video.srcObject=stream;

  await new Promise((resolve)=>{
    function ready(){ if(video.videoWidth>0 && video.videoHeight>0){ video.removeEventListener('loadedmetadata', ready); resolve(); } }
    video.addEventListener('loadedmetadata', ready);
    if (video.readyState >= 2) ready();
  });
  await video.play();
  canvas.width=video.videoWidth||1280;
  canvas.height=video.videoHeight||720;
  videoReady=true;

  if (!fileset) fileset = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.11/wasm");
  if (!landmarker) {
    landmarker = await PoseLandmarker.createFromOptions(fileset,{
      baseOptions:{modelAssetPath:MODEL_URL,delegate:"GPU"},
      runningMode:"VIDEO", numPoses:1, minPoseDetectionConfidence:0.5, minPosePresenceConfidence:0.5, minTrackingConfidence:0.5
    });
  }
}

// 语音（开关 CSV / 切动作 / 相机）
function speak(text){ try{ const u=new SpeechSynthesisUtterance(text); u.lang='zh-CN'; speechSynthesis.speak(u);}catch(e){} }
function setMovementByNumber(n){
  const map={1:'flexion',2:'extension',3:'abduction',4:'int_ext_rot'};
  if(map[n]){ moveSel.value = map[n]; moveSel.dispatchEvent(new Event('change')); speak(`已切换到动作${n}`); }
}
function ensureCsv(on){ if(on && !csvOn){ btnCsv.click(); speak('开始记录'); } if(!on && csvOn){ btnCsv.click(); speak('停止记录'); } }
let recognizer=null, recognizing=false;
function startRecognizer(){
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if(!SR){ alert('当前浏览器不支持语音识别。请使用最新版 Chrome/Edge。'); return; }
  recognizer = new SR();
  recognizer.lang = 'zh-CN';
  recognizer.continuous = true;
  recognizer.interimResults = false;
  recognizer.onresult = (ev)=>{
    const res = ev.results[ev.results.length-1][0].transcript.trim();
    const cmd = res.replace(/\s+/g,'');
    if(/^(开始记录|开始csv|开始)$/.test(cmd)) { ensureCsv(true); return; }
    if(/^(停止记录|停止csv|停止)$/.test(cmd)) { ensureCsv(false); return; }
    const numMap = {'一':1,'二':2,'两':2,'三':3,'四':4};
    let m = cmd.match(/动作([1234一二两三四])/);
    if(m){ const token=m[1]; const n='1234'.includes(token)?parseInt(token,10):numMap[token]; if(n){ setMovementByNumber(n); return; } }
    if(/^[1234]$/.test(cmd)){ setMovementByNumber(parseInt(cmd,10)); return; }
    if(/^[一二两三四]$/.test(cmd)){ setMovementByNumber(numMap[cmd]); return; }
    if(/^(开摄像头|开启摄像头)$/.test(cmd)){ if(!camOn) btnCam.click(); speak('已开启摄像头'); return; }
    if(/^(关摄像头|关闭摄像头)$/.test(cmd)){ if(camOn) btnCam.click(); speak('已关闭摄像头'); return; }
  };
  recognizer.onend = ()=>{ if(recognizing){ try{ recognizer.start(); }catch(e){} } };
  try{ recognizer.start(); recognizing = true; btnVoice.textContent='关闭语音'; speak('语音控制已开启'); }catch(e){}
}
function stopRecognizer(){ if(recognizer){ recognizing=false; try{ recognizer.stop(); }catch(e){} } btnVoice.textContent='开启语音'; speak('语音控制已关闭'); }
btnVoice.addEventListener('click', ()=>{ if(!recognizing) startRecognizer(); else stopRecognizer(); });

// 预加载（不自动开相机）
async function prewarmModel(){
  const loader = document.getElementById('loader');
  try{
    loader.style.display = 'block';
    if(!fileset){ fileset = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.11/wasm"); }
    try{ await fetch(MODEL_URL, {cache:'force-cache', mode:'cors'}); }catch(e){}
    if(!landmarker){
      try{
        landmarker = await PoseLandmarker.createFromOptions(fileset, {
          baseOptions:{ modelAssetPath: MODEL_URL, delegate: "GPU" },
          runningMode:"VIDEO", numPoses:1,
          minPoseDetectionConfidence:0.5, minPosePresenceConfidence:0.5, minTrackingConfidence:0.5
        });
      }catch(e){}
    }
  }finally{ loader.style.display = 'none'; }
}
prewarmModel();

// ===== 主循环（含“确认即写 CSV”）=====
const drawUtil = new DrawingUtils(ctx);
let lastTs = -1;
function loop(){
  if(!camOn){ requestAnimationFrame(loop); return; }
  const ts = performance.now(), tRel = (ts - t0) / 1000;

  let res=null;
  if(videoReady && video.videoWidth>0 && video.videoHeight>0){
    try{ res = landmarker?.detectForVideo(video, ts); }catch(e){ }
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if(mirror){ ctx.save(); ctx.translate(canvas.width, 0); ctx.scale(-1, 1); }
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  if(res?.landmarks?.[0]){
    drawUtil.drawLandmarks(res.landmarks[0], { radius: 2 });
    drawUtil.drawConnectors(res.landmarks[0], PoseLandmarker.POSE_CONNECTIONS);
  }

  if(res?.worldLandmarks?.[0]){
    let bf = alignToBodyFrame(res.worldLandmarks[0]);
    bf = emaUpdate(bf);

    const move = moveSel.value, mode = sideSel.value;
    const minAngle = parseFloat(minAngleInput.value) || 0;

    let angL = NaN, angR = NaN;
    let dispL = NaN, dispR = NaN;

    if (move === "int_ext_rot") {  // 模式4 双向内/外旋
      if (mode === "LEFT" || mode === "BOTH") {
        const L = computeDualRot(bf, "LEFT");
        // 确认时即写入 CSV（内/外分别计）
        writeRotCsvWhenConfirmed("LEFT_EXT", L.ext, tRel, minAngle, "LEFT", "ext_rot");
        writeRotCsvWhenConfirmed("LEFT_INT", L.int, tRel, minAngle, "LEFT", "int_rot");
        angL_el.textContent = `内:${L.int.toFixed(1)}° | max:${rotMax.LEFT_INT.ang.toFixed(1)}° / 外:${L.ext.toFixed(1)}° | max:${rotMax.LEFT_EXT.ang.toFixed(1)}°`;
        dispL = L.val;
      } else { angL_el.textContent = "--.-°"; }

      if (mode === "RIGHT" || mode === "BOTH") {
        const R = computeDualRot(bf, "RIGHT");
        writeRotCsvWhenConfirmed("RIGHT_EXT", R.ext, tRel, minAngle, "RIGHT", "ext_rot");
        writeRotCsvWhenConfirmed("RIGHT_INT", R.int, tRel, minAngle, "RIGHT", "int_rot");
        angR_el.textContent = `内:${R.int.toFixed(1)}° | max:${rotMax.RIGHT_INT.ang.toFixed(1)}° / 外:${R.ext.toFixed(1)}° | max:${rotMax.RIGHT_EXT.ang.toFixed(1)}°`;
        dispR = R.val;
      } else { angR_el.textContent = "--.-°"; }

    } else {  // 模式1/2/3
      if (mode === "LEFT" || mode === "BOTH") {
        const m = getMapFor("LEFT", swapSides);
        angL = computeAngle(bf, m, "LEFT", move).angle;
      }
      if (mode === "RIGHT" || mode === "BOTH") {
        const m = getMapFor("RIGHT", swapSides);
        angR = computeAngle(bf, m, "RIGHT", move).angle;
      }
      dispL = angL; dispR = angR;
      angL_el.textContent = Number.isFinite(angL) ? `${angL.toFixed(1)}°` : "--.-°";
      angR_el.textContent = Number.isFinite(angR) ? `${angR.toFixed(1)}°` : "--.-°";

      // 确认最大角（持续≥1s）→ 立刻写 CSV（含合格列）
      if (Number.isFinite(angL) && (mode==="LEFT"||mode==="BOTH")) {
        if (angL >= minAngle && angL > maxL + 0.1) {
          if (candL===null || angL > candL + 0.1) { candL = angL; tStartL = tRel; }
          if (tRel - tStartL >= HOLD_SECONDS) {
            maxL = candL; maxL_el.textContent = `${maxL.toFixed(1)}°`;
            if (csvOn) {
              const tgt = Number(targetInput.value)||0;
              const moveCode = MOVE_LABEL[move] || move;
              csvRows.push([new Date().toISOString(), mode, "LEFT", moveCode, maxL.toFixed(2), qualify(maxL, tgt)]);
            }
            candL = null; tStartL = null;
          }
        } else { candL = null; tStartL = null; }
      }
      if (Number.isFinite(angR) && (mode==="RIGHT"||mode==="BOTH")) {
        if (angR >= minAngle && angR > maxR + 0.1) {
          if (candR===null || angR > candR + 0.1) { candR = angR; tStartR = tRel; }
          if (tRel - tStartR >= HOLD_SECONDS) {
            maxR = candR; maxR_el.textContent = `${maxR.toFixed(1)}°`;
            if (csvOn) {
              const tgt = Number(targetInput.value)||0;
              const moveCode = MOVE_LABEL[move] || move;
              csvRows.push([new Date().toISOString(), mode, "RIGHT", moveCode, maxR.toFixed(2), qualify(maxR, tgt)]);
            }
            candR = null; tStartR = null;
          }
        } else { candR = null; tStartR = null; }
      }
    }

    // ===== 更新双色进度条 =====
    const tgtCommon = Number(targetInput.value)||0;
    if (move === "int_ext_rot") {
      const tgtInt = Number(targetIntInput.value)||0;
      const tgtExt = Number(targetExtInput.value)||0;
      const dirLabel = (v)=> Number.isFinite(v) ? (v>0?"(外)":"(内)") : "";
      dirLTag.textContent = dirLabel(dispL);
      dirRTag.textContent = dirLabel(dispR);

      const useSide = (val)=>{
        if(!Number.isFinite(val)) return {pct:0,text:"差 --°",ok:false};
        const absv = Math.abs(val);
        const tgt = val>0 ? tgtExt : val<0 ? tgtInt : 0;
        const ok = tgt>0 && absv>=tgt;
        const pct = tgt>0 ? Math.max(0, Math.min(1, absv/Math.max(1,tgt))) : 0;
        const text = ok ? "合格" : (tgt > 0 ? `差 ${(tgt - absv).toFixed(1)}°` : "差 --°");
        return {pct,text,ok};
      };
      const Lp = useSide(dispL), Rp = useSide(dispR);
      paintBar(barL, progL, Lp); paintBar(barR, progR, Rp);
      gapL.textContent = Lp.text; gapR.textContent = Rp.text;
    } else {
      dirLTag.textContent=""; dirRTag.textContent="";
      const Lp = sideProgress(dispL, tgtCommon), Rp = sideProgress(dispR, tgtCommon);
      paintBar(barL, progL, Lp); paintBar(barR, progR, Rp);
      gapL.textContent = Lp.text; gapR.textContent = Rp.text;
    }

    // 曲线更新
    const labels = chart.data.labels, dsL = chart.data.datasets[0], dsR = chart.data.datasets[1];
    labels.push(tRel.toFixed(2));
    dsL.data.push(Number.isFinite(dispL) ? dispL : null);
    dsR.data.push(Number.isFinite(dispR) ? dispR : null);
    while (labels.length > 1 && tRel - parseFloat(labels[0]) > windowSec) {
      labels.shift(); dsL.data.shift(); dsR.data.shift();
    }
    chart.update("none");
  }

  if(mirror){ ctx.restore(); }
  if(lastTs > 0) fps_el.textContent = Math.round(1000 / (ts - lastTs));
  lastTs = ts;
  requestAnimationFrame(loop);
}

// —— 内/外旋：确认即写 CSV 的封装 —— 
function writeRotCsvWhenConfirmed(key, val, tRel, minAngle, side, movementLabel){
  if(!Number.isFinite(val) || val < minAngle){ rotMax[key].tStart = null; return; }
  if(val > rotMax[key].ang + 0.1){
    if(rotMax[key].tStart===null) rotMax[key].tStart = tRel;
    if(tRel - rotMax[key].tStart >= HOLD_SECONDS){
      rotMax[key].ang = val;
      rotMax[key].tStart = null;
      if(csvOn){
        const tgtInt = Number(targetIntInput.value)||0;
        const tgtExt = Number(targetExtInput.value)||0;
        const tgt = (movementLabel==="int_rot")?tgtInt:tgtExt;
        csvRows.push([new Date().toISOString(), sideSel.value, side, movementLabel, val.toFixed(2), qualify(val, tgt)]);
      }
    }
  }else{
    rotMax[key].tStart = null;
  }
}

</script>
</body>
</html>
